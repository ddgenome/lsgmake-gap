# File: Makefile 
# Description: file for auto-generation of sequence analysis
# Auto-generated by @(#) Id: GERALD.pl,v 1.55.2.1 2007/01/03 14:18:01 km Exp
# Auto-generated on Mon Jan 15 07:02:16 2007

# Copyright (c) Solexa Limited 2005
# Author: A. J. Cox


# @(#) $Id: GERALD.pl,v 1.55.2.1 2007/01/03 14:18:01 km Exp $

.SUFFIXES:

# General variable definitions

EXPT_DIR:=/gscmnt/temp220/techd/solexa/solexa2/Runs/070109_SLXA-EAS8_0016_3076/Data/C1-33_Firecrest1.8.26_14-01-2007_mhickenb/Bustard1.8.26_14-01-2007_mhickenb


TOOLS_DIR:=/gsc/pkg/bio/solexa/installed/Gerald
QCAL_TOOLS_DIR:=$(TOOLS_DIR)/../QCalibration
GENOME_DIR:=/gsc/pkg/bio/solexa/installed/Gerald/../../Genomes
GENOME_FILE:=Need_to_specify_genome_file_name
GENOME=${GENOME_DIR}/${GENOME_FILE}
READ_LENGTH:=32

CONTAM_DIR:=/gscmnt/temp210/techd/solexa/contam_dir
CONTAM_FILE:=contam_UK.txt
SEQUENCE_FORMAT:=--fastq
QUALITY_FORMAT:=--symbolic

# If running under Cygwin, need to add a .exe suffix onto
# names of compiled executables

ifdef COMSPEC
EXE:=.exe
endif


# Parameters for called programs...

# ... phageAlign

USE_BASES_CRITERION:=all
USE_BASES= -useBases ${USE_BASES_CRITERION}
PURE_BASES= -pureBases 12

PA:=${TOOLS_DIR}/phageAlign${EXE}

PA_PARAMS=$(GENOME) $(READ_LENGTH) $(READ_LENGTH) $(USE_BASES)
PA_PARAMS_MONO=-tag $(GENOME) $(READ_LENGTH) $(READ_LENGTH) $(USE_BASES)


# ... score.pl

SC:=${TOOLS_DIR}/score.pl
SC_PARAMS=
#SC_PARAMS=$(GENOME)

# ... buildCoverage.pl

BC:=${TOOLS_DIR}/buildCoverage.pl
# Second BC_PARAMS is score threshold below which to ignore alignments
# when building coverage. Leave it out to include them all
BC_PARAMS=$(GENOME) 200


# ... plotCoverage.pl

PC:=${TOOLS_DIR}/plotCoverage.pl

# ... plotErrorRate.pl

PE:=${TOOLS_DIR}/plotErrorRate.pl

# ... quahog

QH:=${TOOLS_DIR}/quahog${EXE}
QH_PARAMS= ${USE_BASES} ${PURE_BASES}
# ... qualityFilter.pl

QF:=${TOOLS_DIR}/qualityFilter.pl
FILTER_CRITERION:='((CHASTITY>=0.6))'
QF_PARAMS= -stamp ${FILTER_CRITERION}

# ... create_error_thumbnails.pl

CE:=${TOOLS_DIR}/create_error_thumbnails.pl
CE_PARAMS=error
CE_PARAMS_SMT=all
CE_PARAMS_PSH=hist
CE_PARAMS_PEC=perfect
CE_PARAMS_PIN=info

# ... convertToFasta.pl

TF:=${TOOLS_DIR}/convertToFasta.pl
TF_PARAMS=${USE_BASES}

# ... convertFromELAND.pl

FI:=${TOOLS_DIR}/convertFromELAND.pl

# ... Signal_Means.pl
SM:=${TOOLS_DIR}/Signal_Means.pl
SM_PARAMS=$(QF) ${FILTER_CRITERION} ${USE_BASES_CRITERION} $(READ_LENGTH) ${EXPT_DIR}

# ... plotIntensity_for_IVC.pl
PI:=${TOOLS_DIR}/plotIntensity_for_IVC.pl

# ... create_IVC_thumbnail.pl
CI:=${TOOLS_DIR}/create_IVC_thumbnail.pl

# ... Signal_Means.pl
SMT:=${TOOLS_DIR}/Signal_Means_Tile.pl
SMT_PARAMS=$(QF) ${FILTER_CRITERION} ${USE_BASES_CRITERION} $(READ_LENGTH)

# ... plotIntensity_for_IVC.pl
PIT:=${TOOLS_DIR}/plotIntensity_tiles.pl

# ... Signal_Means_Monotemplates.pl
SMM:=${TOOLS_DIR}/Signal_Means_Monotemplates.pl
SMM_PARAMS=$(QF) ${FILTER_CRITERION} ${USE_BASES_CRITERION} $(READ_LENGTH)

# ... runReport.pl
RR:=${TOOLS_DIR}/runReport.pl
RR_PARAMS=${CURDIR} localhost:25 \
domain.com \
http://intweb/flake/temp210 \
mhickenb 

# ... plotScoreHist.pl
PSH:=${TOOLS_DIR}/plotScoreHist.pl

# ... plot_Error_Curves.pl
PEC:=${TOOLS_DIR}/plot_Error_Curves.pl

# ... plotInformation.pl
PIN:=${TOOLS_DIR}/plotInformation.pl

# ... plotInformation.pl
BTT:=${TOOLS_DIR}/byTileThumbnailView.pl

# ... plotIntensity_monotemplates.pl
PIM:=${TOOLS_DIR}/plotIntensity_monotemplates.pl

# ... create_IVC_monotemplates_thumbnail.pl 
CMT:=${TOOLS_DIR}/create_IVC_monotemplates_thumbnail.pl 

# ... jerboa.pl
JER:=${TOOLS_DIR}/jerboa.pl

# ... reportQuality.pl
RQ:=${TOOLS_DIR}/reportQuality.pl

# ... convertQuality.pl
CQ:=${TOOLS_DIR}/convertQuality.pl
CQ_PARAMS= --useBases ${USE_BASES_CRITERION} $(QUALITY_FORMAT) ${READ_LENGTH}
 
# ... extractQualityParams.py
EQP:=${QCAL_TOOLS_DIR}/extractQualityParams.py
EQP_PARAMS=--sig-suffix=${SIG_FILE_SUFFIX} --dir=${EXPT_DIR} --USE_BASES=${USE_BASES_CRITERION}
 
# ... QualityCalibration
QLC:=${QCAL_TOOLS_DIR}/QualityCalibration${EXE}
 
# ... QualityApply
QLA:=${QCAL_TOOLS_DIR}/QualityApply${EXE}
QLA_PARAMS:=${QUALITY_FORMAT}

# ... filterQualityValues.pl
FQV:=${TOOLS_DIR}/filterQualityValues.pl
FQV_PARAMS=${USE_BASES_CRITERION} ${QUALITY_FORMAT} ${READ_LENGTH}

# ... buildSeq.pl
BS:=${TOOLS_DIR}/buildSeq.pl



# ...

TOOLS:=$(PA) $(SC) $(BC) $(PC) $(RA) $(PE) $(HM) $(XL) $(PCL) $(QH) \
$(QF) $(CE) $(TF) $(FI) $(SM) $(PI) $(CI) $(SMT) $(PIT) $(SMM) $(RR) $(PSH) \
$(PEC) $(PIN) $(BTT) $(PIM) $(CMT) $(JER) $(RQ) $(EQP) $(QLC) $(QLA) $(FQV) \
$(BS)



# Following are lists of directoreis files and executables  
# that will be checked by make self_test
# These lists may be added to depending on what analysis is asked for
DIRS_TO_CHECK=$(EXPT_DIR) $(TOOLS_DIR) $(QCAL_TOOLS_DIR)
FILES_TO_CHECK=$(TOOLS) 
EXECS_TO_CHECK:=$(TOOLS)

#
# Find lists of files that are inputs to processing  
#

# Eventually this list will be obtained from an XML file

SIG_FILE_SUFFIX_DEPHASED:=_sig2.txt
SIG_FILE_SUFFIX_NOT_DEPHASED:=_sig.txt

SEQ_FILE_SUFFIX:=_seq.txt
SIG_FILE_SUFFIX:=$(SIG_FILE_SUFFIX_DEPHASED)
PRB_FILE_SUFFIX:=_prb.txt

TILE:=s_[1-8]_[0-9][0-9][0-9][0-9]

# Get list of sequence files
ALL_SEQ_FILES:= $(wildcard $(EXPT_DIR)/$(TILE)$(SEQ_FILE_SUFFIX))

# Get list of sig files, if blank try non-phase corrected suffix instead
ALL_SIG_FILES:= $(wildcard $(EXPT_DIR)/$(TILE)$(SIG_FILE_SUFFIX))
ifeq ($(strip $(ALL_SIG_FILES)),)
WARNING_MESSAGES+=Info: no intensity files satisfying \
	$(EXPT_DIR)/$(TILE)$(SIG_FILE_SUFFIX_DEPHASED) found, trying \
	$(EXPT_DIR)/$(TILE)$(SIG_FILE_SUFFIX_NOT_DEPHASED) instead
SIG_FILE_SUFFIX:=$(SIG_FILE_SUFFIX_NOT_DEPHASED)
ALL_SIG_FILES:= $(wildcard $(EXPT_DIR)/$(TILE)$(SIG_FILE_SUFFIX))
endif

ALL_PRB_FILES:= $(wildcard $(EXPT_DIR)/$(TILE)$(PRB_FILE_SUFFIX))

ALL_TILES:=$(patsubst $(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),%,$(ALL_SEQ_FILES))
ALL_SIG_TILES:=$(patsubst $(EXPT_DIR)/%$(SIG_FILE_SUFFIX),%,$(ALL_SIG_FILES))
ALL_PRB_TILES:=$(patsubst $(EXPT_DIR)/%$(PRB_FILE_SUFFIX),%,$(ALL_PRB_FILES))

# This will be blank if the two tiles lists are the same
DIFF_TILES_SIG:=$(filter-out $(ALL_TILES), $(ALL_SIG_TILES))\
$(filter-out $(ALL_SIG_TILES), $(ALL_TILES))

# This will be blank if the two tiles lists are the same ...
DIFF_TILES_PRB:=$(filter-out $(ALL_TILES), $(ALL_PRB_TILES))\
$(filter-out $(ALL_PRB_TILES), $(ALL_TILES))


BAD_TILES:=
# Any tiles listed in BAD_TILES get completely ignored
TILES:=$(filter-out $(BAD_TILES), $(ALL_TILES) )


ALL_LANE_NUMS:=1 2 3 4 5 6 7 8
ALL_LANES:=$(patsubst %,s_%,$(ALL_LANE_NUMS))
LANES:=$(foreach w, $(ALL_LANES), $(findstring $w, $(TILES)))
LANE_TARGETS:=$(patsubst %,%,$(LANES))


#
# All types of files that can be generated are listed here
#

ALIGN_SUFFIX:=_align.txt
QHG_SUFFIX:=_qhg.txt
QALIGN_SUFFIX:=_qalign.txt
REALIGN_SUFFIX:=_realign.txt
SCORE_SUFFIX:=_score.txt
RESCORE_SUFFIX:=_rescore.txt
RESCORE_PNG_SUFFIX:=_rescore.png
COV_SUFFIX:=_cov.txt
COV_PNG_SUFFIX:=_cov.png
SM_SUFFIX:=_Signal_Means.txt
SMT_SUFFIX:=_all.txt
SMT_PNG_SUFFIX:=_all.png
MONO_SUFFIX:=_monotemplate.txt
PSH_PNG_SUFFIX:=_hist.png
PEC_PNG_SUFFIX:=_errors.png
PIN_PNG_SUFFIX:=_info.png
CALIGN_SUFFIX:=_calign.txt
CDIFF_SUFFIX:=_cdiff.txt
CPREDIFF_SUFFIX:=_cprediff.txt
CREDIFF_SUFFIX:=_crediff.txt
PREALIGN_SUFFIX:=_prealign.txt
CREALIGN_SUFFIX:=_crealign.txt
QREP_SUFFIX:=_qreport.txt
QCALREP_SUFFIX:=_qcalreport.txt
QVAL_SUFFIX:=_qval.txt
QTABLE_SUFFIX:=_qtable.txt
QCAL_SUFFIX:=_qcal.txt
QRAW_SUFFIX:=_qraw.txt
SEQUENCE_SUFFIX:=_sequence.txt

OUTPUT_FILE_TYPES+=$(ALIGN_SUFFIX)
OUTPUT_FILE_TYPES+=$(QHG_SUFFIX)
OUTPUT_FILE_TYPES+=$(QALIGN_SUFFIX)
OUTPUT_FILE_TYPES+=$(REALIGN_SUFFIX)
OUTPUT_FILE_TYPES+=$(SCORE_SUFFIX)
OUTPUT_FILE_TYPES+=$(RESCORE_SUFFIX)
OUTPUT_FILE_TYPES+=$(RESCORE_PNG_SUFFIX)
OUTPUT_FILE_TYPES+=$(COV_SUFFIX)
OUTPUT_FILE_TYPES+=$(COV_PNG_SUFFIX)
OUTPUT_FILE_TYPES+=$(SM_SUFFIX)
OUTPUT_FILE_TYPES+=$(SMT_SUFFIX)
OUTPUT_FILE_TYPES+=$(SMT_PNG_SUFFIX)
OUTPUT_FILE_TYPES+=$(MONO_SUFFIX)
OUTPUT_FILE_TYPES+=$(PSH_PNG_SUFFIX)
OUTPUT_FILE_TYPES+=$(PIN_PNG_SUFFIX)
OUTPUT_FILE_TYPES+=$(CALIGN_SUFFIX)
OUTPUT_FILE_TYPES+=$(CDIFF_SUFFIX)
OUTPUT_FILE_TYPES+=$(CPREDIFF_SUFFIX)
OUTPUT_FILE_TYPES+=$(CREDIFF_SUFFIX)
OUTPUT_FILE_TYPES+=$(PREALIGN_SUFFIX)
OUTPUT_FILE_TYPES+=$(CREALIGN_SUFFIX)
OUTPUT_FILE_TYPES+=$(QREP_SUFFIX)


# Chip-wide HTML views
ERROR_THUMB:=Error.htm
SIGNAL_MEANS:=Signal_Means.txt
PLOT_INTENSITY:=plotIntensity_for_IVC
IVC_THUMB:=IVC.htm
SMT_THUMB:=All.htm
PSH_THUMB:=Hist.htm
PEC_THUMB:=Perfect.htm
PIN_THUMB:=Info.htm
BTT_THUMB:=Tile.htm
JER_THUMB:=Summary.htm
RUN_REPORT:=finished.txt

OUTPUT_FILE_TYPES+=$(ERROR_THUMB)
OUTPUT_FILE_TYPES+=$(SIGNAL_MEANS)
OUTPUT_FILE_TYPES+=$(PLOT_INTENSITY)
OUTPUT_FILE_TYPES+=$(IVC_THUMB)
OUTPUT_FILE_TYPES+=$(SMT_THUMB)
OUTPUT_FILE_TYPES+=$(PSH_THUMB)
OUTPUT_FILE_TYPES+=$(PEC_THUMB)
OUTPUT_FILE_TYPES+=$(PIN_THUMB)
OUTPUT_FILE_TYPES+=$(BTT_THUMB)
OUTPUT_FILE_TYPES+=$(JER_THUMB)
OUTPUT_FILE_TYPES+=$(RUN_REPORT)

# Definitions for ELAND
ELAND_RESULT:=eland_result.txt
ELAND_QUERY:=eland_query.txt
ELAND_DIR:=$(TOOLS_DIR)/../Eland/
#ELAND_EXEC:=eland_$(READ_LENGTH)
ELAND_EXEC:=eland
#ELAND_PATH:=$(ELAND_DIR)/$(ELAND_EXEC)
ELAND_GENOME:=/gscmnt/temp210/techd/solexa/reference_sequences/Human_genome_bld36
ELAND_REPEAT:=

# Don't delete any intermediate files
#.SECONDARY:
.PRECIOUS: %$(SMT_SUFFIX) %$(CALIGN_SUFFIX) %$(CREALIGN_SUFFIX) %$(CREDIFF_SUFFIX) %$(CPREDIFF_SUFFIX) %$(RESCORE_SUFFIX) %$(SCORE_SUFFIX) %$(PREALIGN_SUFFIX) %$(REALIGN_SUFFIX) s_%_check_use_bases %$(QTABLE_SUFFIX)

all: self_test warn error $(RUN_REPORT) $(JER_THUMB) $(LANE_TARGETS)
	echo Gerald analysis finished successfully.; /gsc/scripts/bin/createFlake.pl . 
warn:	
ifneq ($(strip $(WARNING_MESSAGES)),)
	$(warning Warning(s) reported: $(WARNING_MESSAGES))
endif



ifeq ($(strip $(ALL_SEQ_FILES)),)
error_no_seq:	
	$(error Error: no sequence files satisfying $(TILE)$(SEQ_FILE_SUFFIX) were found in EXPT_DIR=$(EXPT_DIR))
ERROR_TARGETS+=error_no_seq
endif

# .. die if lists of seq and sig files are not the same
ifneq ($(strip $(DIFF_TILES_SIG)),)
error_seq_sig_diff:	
	$(error Error: $(TILE)$(SEQ_FILE_SUFFIX) and $(TILE)$(SIG_FILE_SUFFIX)\
	 file lists in EXPT_DIR=$(EXPT_DIR) differ!\
	 Differences=$(DIFF_TILES_SIG))
ERROR_TARGETS+=error_seq_sig_diff
endif

# .. die if lists of seq and prb files are not the same
ifneq ($(strip $(DIFF_TILES_PRB)),)
error_seq_prb_diff:	
	$(error Error: $(TILE)$(SEQ_FILE_SUFFIX) and $(TILE)$(PRB_FILE_SUFFIX)\
	 file lists in EXPT_DIR=$(EXPT_DIR) differ!\
	 Differences=$(DIFF_TILES_PRB))
ERROR_TARGETS+=error_seq_prb_diff
endif

error: $(ERROR_TARGETS)	

# Build eland executable for correct read length
$(ELAND_EXEC)_%:    
	$(MAKE) --directory=$(ELAND_DIR) $@
	echo dummy > $@


### Analysis specification for each lane follows ###


# ELAND (whole-genome) analysis requested for lane s_1


s_1_TILES=$(filter s_1%,$(TILES))
ifneq ($(s_1_TILES),)

.PRECIOUS: s_1%$(ALIGN_SUFFIX) s_1%$(SCORE_SUFFIX) s_1%$(PREALIGN_SUFFIX) 
#ELAND_PREREQS+=$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_1_TILES))


THUMBNAIL_TILES+=$(s_1_TILES)

s_1_self_test: DIRS_TO_CHECK+=$(ELAND_GENOME) $(CONTAM_DIR)
s_1_self_test: FILES_TO_CHECK+=$(ELAND_REPEAT) $(CONTAM_DIR)/$(CONTAM_FILE)

s_1_rescore: $(addsuffix $(RESCORE_PNG_SUFFIX), $(s_1_TILES))
s_1_TARGET_LIST+= s_1_rescore

# s_1_eland is a 'placeholder' that makes sure the appropriate
# eland executable has been built
s_1_$(ELAND_EXEC):
	$(MAKE) --directory=$(ELAND_DIR) $(ELAND_EXEC)_$(READ_LENGTH)
	echo dummy > $@


# Build Fasta format query from sequence files
s_1_$(ELAND_QUERY): \
$(patsubst %,$(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),$(s_1_TILES))
	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) \
	$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_1_TILES)) > $(CURDIR)/$@

# Run ELAND to generate results
# Dependency on LAST_ELAND_RESULT ensures only one eland job
# is run at a time, even if run in '-j' mode 
s_1_$(ELAND_RESULT): s_1_$(ELAND_QUERY) s_1_$(ELAND_EXEC)
	$(ELAND_DIR)/$(ELAND_EXEC)_$(READ_LENGTH) s_1_$(ELAND_QUERY) \
	$(ELAND_GENOME) s_1_$(ELAND_RESULT) $(ELAND_REPEAT)

LAST_ELAND_RESULT=s_1_$(ELAND_RESULT)

$(patsubst %,%$(ALIGN_SUFFIX),$(s_1_TILES)): s_1_eland_result.txt

s_1%$(ALIGN_SUFFIX):
#	@echo lane s_1 rule for $@
	cat $^ | $(FI) \
	$(patsubst %$(ALIGN_SUFFIX),%$(SEQ_FILE_SUFFIX),$@) $(READ_LENGTH) \
	> $@

# Create 'simulated' prealign file - just copy align file
s_1%$(PREALIGN_SUFFIX): s_1%$(ALIGN_SUFFIX) s_1%$(SCORE_SUFFIX)
	cat $< > $@


s_1$(QREP_SUFFIX): \
$(addsuffix $(QRAW_SUFFIX), $(filter s_1%, $(TILES))) \
$(addsuffix $(ALIGN_SUFFIX), $(filter s_1%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_1%, $(TILES))) 
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QRAW_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_1%, $(TILES))) \
	> $@
s_1_TARGET_LIST+= s_1$(QREP_SUFFIX)

s_1_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_1_TILES))

s_1$(QCALREP_SUFFIX): \
$(addsuffix $(QCAL_SUFFIX), $(filter s_1%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_1%, $(TILES)))
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QCAL_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_1%, $(TILES))) \
	> $@
s_1_TARGET_LIST+= s_1$(QCALREP_SUFFIX)

s_1_sigs=$(addsuffix $(SIG_FILE_SUFFIX), $(s_1_TILES))
s_1_seqs=$(addsuffix $(SEQ_FILE_SUFFIX), $(s_1_TILES))
s_1_qhgs=$(addsuffix $(QHG_SUFFIX), $(s_1_TILES))

s_1$(SM_SUFFIX):  $(s_1_qhgs)
	$(SM) $(SM_PARAMS) $(s_1_sigs) $(s_1_seqs) $(s_1_qhgs) > $@

SM_PREREQS+=s_1$(SM_SUFFIX)

s_1_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_1_TILES))

s_1$(SEQUENCE_SUFFIX): \
$(s_1_qcals) \
$(addsuffix $(QHG_SUFFIX), $(filter s_1%, $(TILES)))
	$(BS) --useBases $(USE_BASES_CRITERION) \
	--qualityFilter $(QF) $(FILTER_CRITERION) $(SEQUENCE_FORMAT) \
	$(READ_LENGTH) $(EXPT_DIR) $(s_1_qcals) > $@
s_1_TARGET_LIST+= s_1$(SEQUENCE_SUFFIX)

endif
# ELAND (whole-genome) analysis requested for lane s_2


s_2_TILES=$(filter s_2%,$(TILES))
ifneq ($(s_2_TILES),)

.PRECIOUS: s_2%$(ALIGN_SUFFIX) s_2%$(SCORE_SUFFIX) s_2%$(PREALIGN_SUFFIX) 
#ELAND_PREREQS+=$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_2_TILES))


THUMBNAIL_TILES+=$(s_2_TILES)

s_2_self_test: DIRS_TO_CHECK+=$(ELAND_GENOME) $(CONTAM_DIR)
s_2_self_test: FILES_TO_CHECK+=$(ELAND_REPEAT) $(CONTAM_DIR)/$(CONTAM_FILE)

s_2_rescore: $(addsuffix $(RESCORE_PNG_SUFFIX), $(s_2_TILES))
s_2_TARGET_LIST+= s_2_rescore

# s_2_eland is a 'placeholder' that makes sure the appropriate
# eland executable has been built
s_2_$(ELAND_EXEC):
	$(MAKE) --directory=$(ELAND_DIR) $(ELAND_EXEC)_$(READ_LENGTH)
	echo dummy > $@


# Build Fasta format query from sequence files
s_2_$(ELAND_QUERY): \
$(patsubst %,$(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),$(s_2_TILES))
	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) \
	$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_2_TILES)) > $(CURDIR)/$@

# Run ELAND to generate results
# Dependency on LAST_ELAND_RESULT ensures only one eland job
# is run at a time, even if run in '-j' mode 
s_2_$(ELAND_RESULT): s_2_$(ELAND_QUERY) s_2_$(ELAND_EXEC)
	$(ELAND_DIR)/$(ELAND_EXEC)_$(READ_LENGTH) s_2_$(ELAND_QUERY) \
	$(ELAND_GENOME) s_2_$(ELAND_RESULT) $(ELAND_REPEAT)

LAST_ELAND_RESULT=s_2_$(ELAND_RESULT)

$(patsubst %,%$(ALIGN_SUFFIX),$(s_2_TILES)): s_2_eland_result.txt

s_2%$(ALIGN_SUFFIX):
#	@echo lane s_2 rule for $@
	cat $^ | $(FI) \
	$(patsubst %$(ALIGN_SUFFIX),%$(SEQ_FILE_SUFFIX),$@) $(READ_LENGTH) \
	> $@

# Create 'simulated' prealign file - just copy align file
s_2%$(PREALIGN_SUFFIX): s_2%$(ALIGN_SUFFIX) s_2%$(SCORE_SUFFIX)
	cat $< > $@


s_2$(QREP_SUFFIX): \
$(addsuffix $(QRAW_SUFFIX), $(filter s_2%, $(TILES))) \
$(addsuffix $(ALIGN_SUFFIX), $(filter s_2%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_2%, $(TILES))) 
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QRAW_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_2%, $(TILES))) \
	> $@
s_2_TARGET_LIST+= s_2$(QREP_SUFFIX)

s_2_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_2_TILES))

s_2$(QCALREP_SUFFIX): \
$(addsuffix $(QCAL_SUFFIX), $(filter s_2%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_2%, $(TILES)))
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QCAL_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_2%, $(TILES))) \
	> $@
s_2_TARGET_LIST+= s_2$(QCALREP_SUFFIX)

s_2_sigs=$(addsuffix $(SIG_FILE_SUFFIX), $(s_2_TILES))
s_2_seqs=$(addsuffix $(SEQ_FILE_SUFFIX), $(s_2_TILES))
s_2_qhgs=$(addsuffix $(QHG_SUFFIX), $(s_2_TILES))

s_2$(SM_SUFFIX):  $(s_2_qhgs)
	$(SM) $(SM_PARAMS) $(s_2_sigs) $(s_2_seqs) $(s_2_qhgs) > $@

SM_PREREQS+=s_2$(SM_SUFFIX)

s_2_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_2_TILES))

s_2$(SEQUENCE_SUFFIX): \
$(s_2_qcals) \
$(addsuffix $(QHG_SUFFIX), $(filter s_2%, $(TILES)))
	$(BS) --useBases $(USE_BASES_CRITERION) \
	--qualityFilter $(QF) $(FILTER_CRITERION) $(SEQUENCE_FORMAT) \
	$(READ_LENGTH) $(EXPT_DIR) $(s_2_qcals) > $@
s_2_TARGET_LIST+= s_2$(SEQUENCE_SUFFIX)

endif
# ELAND (whole-genome) analysis requested for lane s_3


s_3_TILES=$(filter s_3%,$(TILES))
ifneq ($(s_3_TILES),)

.PRECIOUS: s_3%$(ALIGN_SUFFIX) s_3%$(SCORE_SUFFIX) s_3%$(PREALIGN_SUFFIX) 
#ELAND_PREREQS+=$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_3_TILES))


THUMBNAIL_TILES+=$(s_3_TILES)

s_3_self_test: DIRS_TO_CHECK+=$(ELAND_GENOME) $(CONTAM_DIR)
s_3_self_test: FILES_TO_CHECK+=$(ELAND_REPEAT) $(CONTAM_DIR)/$(CONTAM_FILE)

s_3_rescore: $(addsuffix $(RESCORE_PNG_SUFFIX), $(s_3_TILES))
s_3_TARGET_LIST+= s_3_rescore

# s_3_eland is a 'placeholder' that makes sure the appropriate
# eland executable has been built
s_3_$(ELAND_EXEC):
	$(MAKE) --directory=$(ELAND_DIR) $(ELAND_EXEC)_$(READ_LENGTH)
	echo dummy > $@


# Build Fasta format query from sequence files
s_3_$(ELAND_QUERY): \
$(patsubst %,$(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),$(s_3_TILES))
	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) \
	$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_3_TILES)) > $(CURDIR)/$@

# Run ELAND to generate results
# Dependency on LAST_ELAND_RESULT ensures only one eland job
# is run at a time, even if run in '-j' mode 
s_3_$(ELAND_RESULT): s_3_$(ELAND_QUERY) s_3_$(ELAND_EXEC)
	$(ELAND_DIR)/$(ELAND_EXEC)_$(READ_LENGTH) s_3_$(ELAND_QUERY) \
	$(ELAND_GENOME) s_3_$(ELAND_RESULT) $(ELAND_REPEAT)

LAST_ELAND_RESULT=s_3_$(ELAND_RESULT)

$(patsubst %,%$(ALIGN_SUFFIX),$(s_3_TILES)): s_3_eland_result.txt

s_3%$(ALIGN_SUFFIX):
#	@echo lane s_3 rule for $@
	cat $^ | $(FI) \
	$(patsubst %$(ALIGN_SUFFIX),%$(SEQ_FILE_SUFFIX),$@) $(READ_LENGTH) \
	> $@

# Create 'simulated' prealign file - just copy align file
s_3%$(PREALIGN_SUFFIX): s_3%$(ALIGN_SUFFIX) s_3%$(SCORE_SUFFIX)
	cat $< > $@


s_3$(QREP_SUFFIX): \
$(addsuffix $(QRAW_SUFFIX), $(filter s_3%, $(TILES))) \
$(addsuffix $(ALIGN_SUFFIX), $(filter s_3%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_3%, $(TILES))) 
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QRAW_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_3%, $(TILES))) \
	> $@
s_3_TARGET_LIST+= s_3$(QREP_SUFFIX)

s_3_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_3_TILES))

s_3$(QCALREP_SUFFIX): \
$(addsuffix $(QCAL_SUFFIX), $(filter s_3%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_3%, $(TILES)))
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QCAL_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_3%, $(TILES))) \
	> $@
s_3_TARGET_LIST+= s_3$(QCALREP_SUFFIX)

s_3_sigs=$(addsuffix $(SIG_FILE_SUFFIX), $(s_3_TILES))
s_3_seqs=$(addsuffix $(SEQ_FILE_SUFFIX), $(s_3_TILES))
s_3_qhgs=$(addsuffix $(QHG_SUFFIX), $(s_3_TILES))

s_3$(SM_SUFFIX):  $(s_3_qhgs)
	$(SM) $(SM_PARAMS) $(s_3_sigs) $(s_3_seqs) $(s_3_qhgs) > $@

SM_PREREQS+=s_3$(SM_SUFFIX)

s_3_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_3_TILES))

s_3$(SEQUENCE_SUFFIX): \
$(s_3_qcals) \
$(addsuffix $(QHG_SUFFIX), $(filter s_3%, $(TILES)))
	$(BS) --useBases $(USE_BASES_CRITERION) \
	--qualityFilter $(QF) $(FILTER_CRITERION) $(SEQUENCE_FORMAT) \
	$(READ_LENGTH) $(EXPT_DIR) $(s_3_qcals) > $@
s_3_TARGET_LIST+= s_3$(SEQUENCE_SUFFIX)

endif
# ELAND (whole-genome) analysis requested for lane s_4


s_4_TILES=$(filter s_4%,$(TILES))
ifneq ($(s_4_TILES),)

.PRECIOUS: s_4%$(ALIGN_SUFFIX) s_4%$(SCORE_SUFFIX) s_4%$(PREALIGN_SUFFIX) 
#ELAND_PREREQS+=$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_4_TILES))


THUMBNAIL_TILES+=$(s_4_TILES)

s_4_self_test: DIRS_TO_CHECK+=$(ELAND_GENOME) $(CONTAM_DIR)
s_4_self_test: FILES_TO_CHECK+=$(ELAND_REPEAT) $(CONTAM_DIR)/$(CONTAM_FILE)

s_4_rescore: $(addsuffix $(RESCORE_PNG_SUFFIX), $(s_4_TILES))
s_4_TARGET_LIST+= s_4_rescore

# s_4_eland is a 'placeholder' that makes sure the appropriate
# eland executable has been built
s_4_$(ELAND_EXEC):
	$(MAKE) --directory=$(ELAND_DIR) $(ELAND_EXEC)_$(READ_LENGTH)
	echo dummy > $@


# Build Fasta format query from sequence files
s_4_$(ELAND_QUERY): \
$(patsubst %,$(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),$(s_4_TILES))
	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) \
	$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_4_TILES)) > $(CURDIR)/$@

# Run ELAND to generate results
# Dependency on LAST_ELAND_RESULT ensures only one eland job
# is run at a time, even if run in '-j' mode 
s_4_$(ELAND_RESULT): s_4_$(ELAND_QUERY) s_4_$(ELAND_EXEC)
	$(ELAND_DIR)/$(ELAND_EXEC)_$(READ_LENGTH) s_4_$(ELAND_QUERY) \
	$(ELAND_GENOME) s_4_$(ELAND_RESULT) $(ELAND_REPEAT)

LAST_ELAND_RESULT=s_4_$(ELAND_RESULT)

$(patsubst %,%$(ALIGN_SUFFIX),$(s_4_TILES)): s_4_eland_result.txt

s_4%$(ALIGN_SUFFIX):
#	@echo lane s_4 rule for $@
	cat $^ | $(FI) \
	$(patsubst %$(ALIGN_SUFFIX),%$(SEQ_FILE_SUFFIX),$@) $(READ_LENGTH) \
	> $@

# Create 'simulated' prealign file - just copy align file
s_4%$(PREALIGN_SUFFIX): s_4%$(ALIGN_SUFFIX) s_4%$(SCORE_SUFFIX)
	cat $< > $@


s_4$(QREP_SUFFIX): \
$(addsuffix $(QRAW_SUFFIX), $(filter s_4%, $(TILES))) \
$(addsuffix $(ALIGN_SUFFIX), $(filter s_4%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_4%, $(TILES))) 
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QRAW_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_4%, $(TILES))) \
	> $@
s_4_TARGET_LIST+= s_4$(QREP_SUFFIX)

s_4_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_4_TILES))

s_4$(QCALREP_SUFFIX): \
$(addsuffix $(QCAL_SUFFIX), $(filter s_4%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_4%, $(TILES)))
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QCAL_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_4%, $(TILES))) \
	> $@
s_4_TARGET_LIST+= s_4$(QCALREP_SUFFIX)

s_4_sigs=$(addsuffix $(SIG_FILE_SUFFIX), $(s_4_TILES))
s_4_seqs=$(addsuffix $(SEQ_FILE_SUFFIX), $(s_4_TILES))
s_4_qhgs=$(addsuffix $(QHG_SUFFIX), $(s_4_TILES))

s_4$(SM_SUFFIX):  $(s_4_qhgs)
	$(SM) $(SM_PARAMS) $(s_4_sigs) $(s_4_seqs) $(s_4_qhgs) > $@

SM_PREREQS+=s_4$(SM_SUFFIX)

s_4_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_4_TILES))

s_4$(SEQUENCE_SUFFIX): \
$(s_4_qcals) \
$(addsuffix $(QHG_SUFFIX), $(filter s_4%, $(TILES)))
	$(BS) --useBases $(USE_BASES_CRITERION) \
	--qualityFilter $(QF) $(FILTER_CRITERION) $(SEQUENCE_FORMAT) \
	$(READ_LENGTH) $(EXPT_DIR) $(s_4_qcals) > $@
s_4_TARGET_LIST+= s_4$(SEQUENCE_SUFFIX)

endif
# ELAND (whole-genome) analysis requested for lane s_5


s_5_TILES=$(filter s_5%,$(TILES))
ifneq ($(s_5_TILES),)

.PRECIOUS: s_5%$(ALIGN_SUFFIX) s_5%$(SCORE_SUFFIX) s_5%$(PREALIGN_SUFFIX) 
#ELAND_PREREQS+=$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_5_TILES))


THUMBNAIL_TILES+=$(s_5_TILES)

s_5_self_test: DIRS_TO_CHECK+=$(ELAND_GENOME) $(CONTAM_DIR)
s_5_self_test: FILES_TO_CHECK+=$(ELAND_REPEAT) $(CONTAM_DIR)/$(CONTAM_FILE)

s_5_rescore: $(addsuffix $(RESCORE_PNG_SUFFIX), $(s_5_TILES))
s_5_TARGET_LIST+= s_5_rescore

# s_5_eland is a 'placeholder' that makes sure the appropriate
# eland executable has been built
s_5_$(ELAND_EXEC):
	$(MAKE) --directory=$(ELAND_DIR) $(ELAND_EXEC)_$(READ_LENGTH)
	echo dummy > $@


# Build Fasta format query from sequence files
s_5_$(ELAND_QUERY): \
$(patsubst %,$(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),$(s_5_TILES))
	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) \
	$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_5_TILES)) > $(CURDIR)/$@

# Run ELAND to generate results
# Dependency on LAST_ELAND_RESULT ensures only one eland job
# is run at a time, even if run in '-j' mode 
s_5_$(ELAND_RESULT): s_5_$(ELAND_QUERY) s_5_$(ELAND_EXEC)
	$(ELAND_DIR)/$(ELAND_EXEC)_$(READ_LENGTH) s_5_$(ELAND_QUERY) \
	$(ELAND_GENOME) s_5_$(ELAND_RESULT) $(ELAND_REPEAT)

LAST_ELAND_RESULT=s_5_$(ELAND_RESULT)

$(patsubst %,%$(ALIGN_SUFFIX),$(s_5_TILES)): s_5_eland_result.txt

s_5%$(ALIGN_SUFFIX):
#	@echo lane s_5 rule for $@
	cat $^ | $(FI) \
	$(patsubst %$(ALIGN_SUFFIX),%$(SEQ_FILE_SUFFIX),$@) $(READ_LENGTH) \
	> $@

# Create 'simulated' prealign file - just copy align file
s_5%$(PREALIGN_SUFFIX): s_5%$(ALIGN_SUFFIX) s_5%$(SCORE_SUFFIX)
	cat $< > $@


s_5$(QREP_SUFFIX): \
$(addsuffix $(QRAW_SUFFIX), $(filter s_5%, $(TILES))) \
$(addsuffix $(ALIGN_SUFFIX), $(filter s_5%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_5%, $(TILES))) 
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QRAW_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_5%, $(TILES))) \
	> $@
s_5_TARGET_LIST+= s_5$(QREP_SUFFIX)

s_5_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_5_TILES))

s_5$(QCALREP_SUFFIX): \
$(addsuffix $(QCAL_SUFFIX), $(filter s_5%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_5%, $(TILES)))
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QCAL_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_5%, $(TILES))) \
	> $@
s_5_TARGET_LIST+= s_5$(QCALREP_SUFFIX)

s_5_sigs=$(addsuffix $(SIG_FILE_SUFFIX), $(s_5_TILES))
s_5_seqs=$(addsuffix $(SEQ_FILE_SUFFIX), $(s_5_TILES))
s_5_qhgs=$(addsuffix $(QHG_SUFFIX), $(s_5_TILES))

s_5$(SM_SUFFIX):  $(s_5_qhgs)
	$(SM) $(SM_PARAMS) $(s_5_sigs) $(s_5_seqs) $(s_5_qhgs) > $@

SM_PREREQS+=s_5$(SM_SUFFIX)

s_5_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_5_TILES))

s_5$(SEQUENCE_SUFFIX): \
$(s_5_qcals) \
$(addsuffix $(QHG_SUFFIX), $(filter s_5%, $(TILES)))
	$(BS) --useBases $(USE_BASES_CRITERION) \
	--qualityFilter $(QF) $(FILTER_CRITERION) $(SEQUENCE_FORMAT) \
	$(READ_LENGTH) $(EXPT_DIR) $(s_5_qcals) > $@
s_5_TARGET_LIST+= s_5$(SEQUENCE_SUFFIX)

endif
# ELAND (whole-genome) analysis requested for lane s_6


s_6_TILES=$(filter s_6%,$(TILES))
ifneq ($(s_6_TILES),)

.PRECIOUS: s_6%$(ALIGN_SUFFIX) s_6%$(SCORE_SUFFIX) s_6%$(PREALIGN_SUFFIX) 
#ELAND_PREREQS+=$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_6_TILES))


THUMBNAIL_TILES+=$(s_6_TILES)

s_6_self_test: DIRS_TO_CHECK+=$(ELAND_GENOME) $(CONTAM_DIR)
s_6_self_test: FILES_TO_CHECK+=$(ELAND_REPEAT) $(CONTAM_DIR)/$(CONTAM_FILE)

s_6_rescore: $(addsuffix $(RESCORE_PNG_SUFFIX), $(s_6_TILES))
s_6_TARGET_LIST+= s_6_rescore

# s_6_eland is a 'placeholder' that makes sure the appropriate
# eland executable has been built
s_6_$(ELAND_EXEC):
	$(MAKE) --directory=$(ELAND_DIR) $(ELAND_EXEC)_$(READ_LENGTH)
	echo dummy > $@


# Build Fasta format query from sequence files
s_6_$(ELAND_QUERY): \
$(patsubst %,$(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),$(s_6_TILES))
	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) \
	$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_6_TILES)) > $(CURDIR)/$@

# Run ELAND to generate results
# Dependency on LAST_ELAND_RESULT ensures only one eland job
# is run at a time, even if run in '-j' mode 
s_6_$(ELAND_RESULT): s_6_$(ELAND_QUERY) s_6_$(ELAND_EXEC)
	$(ELAND_DIR)/$(ELAND_EXEC)_$(READ_LENGTH) s_6_$(ELAND_QUERY) \
	$(ELAND_GENOME) s_6_$(ELAND_RESULT) $(ELAND_REPEAT)

LAST_ELAND_RESULT=s_6_$(ELAND_RESULT)

$(patsubst %,%$(ALIGN_SUFFIX),$(s_6_TILES)): s_6_eland_result.txt

s_6%$(ALIGN_SUFFIX):
#	@echo lane s_6 rule for $@
	cat $^ | $(FI) \
	$(patsubst %$(ALIGN_SUFFIX),%$(SEQ_FILE_SUFFIX),$@) $(READ_LENGTH) \
	> $@

# Create 'simulated' prealign file - just copy align file
s_6%$(PREALIGN_SUFFIX): s_6%$(ALIGN_SUFFIX) s_6%$(SCORE_SUFFIX)
	cat $< > $@


s_6$(QREP_SUFFIX): \
$(addsuffix $(QRAW_SUFFIX), $(filter s_6%, $(TILES))) \
$(addsuffix $(ALIGN_SUFFIX), $(filter s_6%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_6%, $(TILES))) 
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QRAW_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_6%, $(TILES))) \
	> $@
s_6_TARGET_LIST+= s_6$(QREP_SUFFIX)

s_6_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_6_TILES))

s_6$(QCALREP_SUFFIX): \
$(addsuffix $(QCAL_SUFFIX), $(filter s_6%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_6%, $(TILES)))
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QCAL_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_6%, $(TILES))) \
	> $@
s_6_TARGET_LIST+= s_6$(QCALREP_SUFFIX)

s_6_sigs=$(addsuffix $(SIG_FILE_SUFFIX), $(s_6_TILES))
s_6_seqs=$(addsuffix $(SEQ_FILE_SUFFIX), $(s_6_TILES))
s_6_qhgs=$(addsuffix $(QHG_SUFFIX), $(s_6_TILES))

s_6$(SM_SUFFIX):  $(s_6_qhgs)
	$(SM) $(SM_PARAMS) $(s_6_sigs) $(s_6_seqs) $(s_6_qhgs) > $@

SM_PREREQS+=s_6$(SM_SUFFIX)

s_6_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_6_TILES))

s_6$(SEQUENCE_SUFFIX): \
$(s_6_qcals) \
$(addsuffix $(QHG_SUFFIX), $(filter s_6%, $(TILES)))
	$(BS) --useBases $(USE_BASES_CRITERION) \
	--qualityFilter $(QF) $(FILTER_CRITERION) $(SEQUENCE_FORMAT) \
	$(READ_LENGTH) $(EXPT_DIR) $(s_6_qcals) > $@
s_6_TARGET_LIST+= s_6$(SEQUENCE_SUFFIX)

endif
# ELAND (whole-genome) analysis requested for lane s_7


s_7_TILES=$(filter s_7%,$(TILES))
ifneq ($(s_7_TILES),)

.PRECIOUS: s_7%$(ALIGN_SUFFIX) s_7%$(SCORE_SUFFIX) s_7%$(PREALIGN_SUFFIX) 
#ELAND_PREREQS+=$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_7_TILES))


THUMBNAIL_TILES+=$(s_7_TILES)

s_7_self_test: DIRS_TO_CHECK+=$(ELAND_GENOME) $(CONTAM_DIR)
s_7_self_test: FILES_TO_CHECK+=$(ELAND_REPEAT) $(CONTAM_DIR)/$(CONTAM_FILE)

s_7_rescore: $(addsuffix $(RESCORE_PNG_SUFFIX), $(s_7_TILES))
s_7_TARGET_LIST+= s_7_rescore

# s_7_eland is a 'placeholder' that makes sure the appropriate
# eland executable has been built
s_7_$(ELAND_EXEC):
	$(MAKE) --directory=$(ELAND_DIR) $(ELAND_EXEC)_$(READ_LENGTH)
	echo dummy > $@


# Build Fasta format query from sequence files
s_7_$(ELAND_QUERY): \
$(patsubst %,$(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),$(s_7_TILES))
	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) \
	$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_7_TILES)) > $(CURDIR)/$@

# Run ELAND to generate results
# Dependency on LAST_ELAND_RESULT ensures only one eland job
# is run at a time, even if run in '-j' mode 
s_7_$(ELAND_RESULT): s_7_$(ELAND_QUERY) s_7_$(ELAND_EXEC)
	$(ELAND_DIR)/$(ELAND_EXEC)_$(READ_LENGTH) s_7_$(ELAND_QUERY) \
	$(ELAND_GENOME) s_7_$(ELAND_RESULT) $(ELAND_REPEAT)

LAST_ELAND_RESULT=s_7_$(ELAND_RESULT)

$(patsubst %,%$(ALIGN_SUFFIX),$(s_7_TILES)): s_7_eland_result.txt

s_7%$(ALIGN_SUFFIX):
#	@echo lane s_7 rule for $@
	cat $^ | $(FI) \
	$(patsubst %$(ALIGN_SUFFIX),%$(SEQ_FILE_SUFFIX),$@) $(READ_LENGTH) \
	> $@

# Create 'simulated' prealign file - just copy align file
s_7%$(PREALIGN_SUFFIX): s_7%$(ALIGN_SUFFIX) s_7%$(SCORE_SUFFIX)
	cat $< > $@


s_7$(QREP_SUFFIX): \
$(addsuffix $(QRAW_SUFFIX), $(filter s_7%, $(TILES))) \
$(addsuffix $(ALIGN_SUFFIX), $(filter s_7%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_7%, $(TILES))) 
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QRAW_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_7%, $(TILES))) \
	> $@
s_7_TARGET_LIST+= s_7$(QREP_SUFFIX)

s_7_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_7_TILES))

s_7$(QCALREP_SUFFIX): \
$(addsuffix $(QCAL_SUFFIX), $(filter s_7%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_7%, $(TILES)))
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QCAL_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_7%, $(TILES))) \
	> $@
s_7_TARGET_LIST+= s_7$(QCALREP_SUFFIX)

s_7_sigs=$(addsuffix $(SIG_FILE_SUFFIX), $(s_7_TILES))
s_7_seqs=$(addsuffix $(SEQ_FILE_SUFFIX), $(s_7_TILES))
s_7_qhgs=$(addsuffix $(QHG_SUFFIX), $(s_7_TILES))

s_7$(SM_SUFFIX):  $(s_7_qhgs)
	$(SM) $(SM_PARAMS) $(s_7_sigs) $(s_7_seqs) $(s_7_qhgs) > $@

SM_PREREQS+=s_7$(SM_SUFFIX)

s_7_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_7_TILES))

s_7$(SEQUENCE_SUFFIX): \
$(s_7_qcals) \
$(addsuffix $(QHG_SUFFIX), $(filter s_7%, $(TILES)))
	$(BS) --useBases $(USE_BASES_CRITERION) \
	--qualityFilter $(QF) $(FILTER_CRITERION) $(SEQUENCE_FORMAT) \
	$(READ_LENGTH) $(EXPT_DIR) $(s_7_qcals) > $@
s_7_TARGET_LIST+= s_7$(SEQUENCE_SUFFIX)

endif
# ELAND (whole-genome) analysis requested for lane s_8


s_8_TILES=$(filter s_8%,$(TILES))
ifneq ($(s_8_TILES),)

.PRECIOUS: s_8%$(ALIGN_SUFFIX) s_8%$(SCORE_SUFFIX) s_8%$(PREALIGN_SUFFIX) 
#ELAND_PREREQS+=$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_8_TILES))


THUMBNAIL_TILES+=$(s_8_TILES)

s_8_self_test: DIRS_TO_CHECK+=$(ELAND_GENOME) $(CONTAM_DIR)
s_8_self_test: FILES_TO_CHECK+=$(ELAND_REPEAT) $(CONTAM_DIR)/$(CONTAM_FILE)

s_8_rescore: $(addsuffix $(RESCORE_PNG_SUFFIX), $(s_8_TILES))
s_8_TARGET_LIST+= s_8_rescore

# s_8_eland is a 'placeholder' that makes sure the appropriate
# eland executable has been built
s_8_$(ELAND_EXEC):
	$(MAKE) --directory=$(ELAND_DIR) $(ELAND_EXEC)_$(READ_LENGTH)
	echo dummy > $@


# Build Fasta format query from sequence files
s_8_$(ELAND_QUERY): \
$(patsubst %,$(EXPT_DIR)/%$(SEQ_FILE_SUFFIX),$(s_8_TILES))
	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) \
	$(patsubst %,%$(SEQ_FILE_SUFFIX),$(s_8_TILES)) > $(CURDIR)/$@

# Run ELAND to generate results
# Dependency on LAST_ELAND_RESULT ensures only one eland job
# is run at a time, even if run in '-j' mode 
s_8_$(ELAND_RESULT): s_8_$(ELAND_QUERY) s_8_$(ELAND_EXEC)
	$(ELAND_DIR)/$(ELAND_EXEC)_$(READ_LENGTH) s_8_$(ELAND_QUERY) \
	$(ELAND_GENOME) s_8_$(ELAND_RESULT) $(ELAND_REPEAT)

LAST_ELAND_RESULT=s_8_$(ELAND_RESULT)

$(patsubst %,%$(ALIGN_SUFFIX),$(s_8_TILES)): s_8_eland_result.txt

s_8%$(ALIGN_SUFFIX):
#	@echo lane s_8 rule for $@
	cat $^ | $(FI) \
	$(patsubst %$(ALIGN_SUFFIX),%$(SEQ_FILE_SUFFIX),$@) $(READ_LENGTH) \
	> $@

# Create 'simulated' prealign file - just copy align file
s_8%$(PREALIGN_SUFFIX): s_8%$(ALIGN_SUFFIX) s_8%$(SCORE_SUFFIX)
	cat $< > $@


s_8$(QREP_SUFFIX): \
$(addsuffix $(QRAW_SUFFIX), $(filter s_8%, $(TILES))) \
$(addsuffix $(ALIGN_SUFFIX), $(filter s_8%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_8%, $(TILES))) 
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QRAW_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_8%, $(TILES))) \
	> $@
s_8_TARGET_LIST+= s_8$(QREP_SUFFIX)

s_8_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_8_TILES))

s_8$(QCALREP_SUFFIX): \
$(addsuffix $(QCAL_SUFFIX), $(filter s_8%, $(TILES))) \
$(addsuffix $(QHG_SUFFIX), $(filter s_8%, $(TILES)))
	$(RQ) -qualityFilter $(QF) $(FILTER_CRITERION) \
	$(READ_LENGTH) $(QCAL_SUFFIX) $(QUALITY_FORMAT) \
	$(addsuffix $(ALIGN_SUFFIX), $(filter s_8%, $(TILES))) \
	> $@
s_8_TARGET_LIST+= s_8$(QCALREP_SUFFIX)

s_8_sigs=$(addsuffix $(SIG_FILE_SUFFIX), $(s_8_TILES))
s_8_seqs=$(addsuffix $(SEQ_FILE_SUFFIX), $(s_8_TILES))
s_8_qhgs=$(addsuffix $(QHG_SUFFIX), $(s_8_TILES))

s_8$(SM_SUFFIX):  $(s_8_qhgs)
	$(SM) $(SM_PARAMS) $(s_8_sigs) $(s_8_seqs) $(s_8_qhgs) > $@

SM_PREREQS+=s_8$(SM_SUFFIX)

s_8_qcals=$(addsuffix $(QCAL_SUFFIX), $(s_8_TILES))

s_8$(SEQUENCE_SUFFIX): \
$(s_8_qcals) \
$(addsuffix $(QHG_SUFFIX), $(filter s_8%, $(TILES)))
	$(BS) --useBases $(USE_BASES_CRITERION) \
	--qualityFilter $(QF) $(FILTER_CRITERION) $(SEQUENCE_FORMAT) \
	$(READ_LENGTH) $(EXPT_DIR) $(s_8_qcals) > $@
s_8_TARGET_LIST+= s_8$(SEQUENCE_SUFFIX)

endif
### End of lane-specific analysis ###


# If the above necessitates some eland analysis, then define
# all the targets necessary to run it
ifdef LAST_ELAND_RESULT
DIRS_TO_CHECK+=$(ELAND_DIR)
FILES_TO_CHECK+=$(ELAND_REPEAT)


# Build Fasta format query from sequence files
#$(ELAND_QUERY): $(patsubst %,$(EXPT_DIR)/%,$(ELAND_PREREQS))
#	cd $(EXPT_DIR); $(TF) $(TF_PARAMS) $(ELAND_PREREQS) > $(CURDIR)/$@

# Run ELAND to generate results
#$(ELAND_RESULT): $(ELAND_QUERY) $(ELAND_EXEC)
#	@echo running eland on  $^
#	$(ELAND_PATH) $(ELAND_QUERY) $(ELAND_GENOME) $(ELAND_RESULT)\
#	$(ELAND_REPEAT)

endif # ELAND_PREREQS

# If the above necessitates some monotemplate analysis, then define
# all the targets necessary to run it
ifdef MONO_PREREQS

# Definitions for monotemplate analysis
MONO_RESULT:=Monotemplate.txt

$(MONO_RESULT): $(MONO_PREREQS)
	cat $^ > $@

PLOT_INTENSITY_MONO:=plotIntensity_monotemplates

$(PLOT_INTENSITY_MONO): $(MONO_RESULT)
	$(PIM) $(MONO_RESULT) $(CURDIR)
	echo dummy > $@

MONO_THUMB:=Monotemplate.htm

$(MONO_THUMB): $(PLOT_INTENSITY_MONO)
	$(CMT) $(CURDIR) $(MONO_LANES) > $@

JER_PREREQS+=$(MONO_THUMB)

OUTPUT_FILE_TYPES+=$(MONO_RESULT) $(PLOT_INTENSITY_MONO) $(MONO_THUMB)


endif # MONO_PREREQS

ifdef CONTAM_FILE

PA_PARAMS_CONTAM=-tag $(CONTAM_DIR)/$(CONTAM_FILE) $(READ_LENGTH) $(READ_LENGTH) $(USE_BASES)
 
contam: $(addsuffix $(CDIFF_SUFFIX), $(CONTAM_TILES))

# Add contaminant target (TBD - make this lane-by-lane)
all+=contam

# Alignment to contaminant
%$(CALIGN_SUFFIX): $(EXPT_DIR)/%$(SEQ_FILE_SUFFIX) $(PA)
	$(PA) $(PA_PARAMS_CONTAM) $<\
	| perl -lane '{ print unless (/^\#/) }' > $@

# Alignment to data minus alignment to contaminant - negative for contaminants 
%$(CDIFF_SUFFIX): %$(CALIGN_SUFFIX) %$(ALIGN_SUFFIX)
	cat $*$(ALIGN_SUFFIX) | grep -v '^\#' | cut -d" " -f2 \
	| paste - $*$(CALIGN_SUFFIX)  \
	| perl -lane '{ print $$F[0]-$$F[2] }' > $@

# Alignment to contaminant using alignment scores from first pass
%$(CREALIGN_SUFFIX): $(EXPT_DIR)/%$(SEQ_FILE_SUFFIX) $(PA)\
%$(SCORE_SUFFIX)
	$(PA) $(PA_PARAMS_CONTAM) -scoreFile $*$(SCORE_SUFFIX) $<\
	| perl -lane '{ print unless (/^\#/) }' > $@

# Alignment to data minus alignment to contaminant - realigned data
%$(CPREDIFF_SUFFIX): %$(CREALIGN_SUFFIX) %$(PREALIGN_SUFFIX)
	cat $*$(PREALIGN_SUFFIX) | grep -v '^\#' | cut -d" " -f2 \
	| paste - $*$(CREALIGN_SUFFIX)  \
	| perl -lane '{ print $$F[0]-$$F[2] }' > $@
# Alignment to data minus alignment to contaminant - realigned + filtered data
%$(CREDIFF_SUFFIX): %$(CPREDIFF_SUFFIX) %$(QHG_SUFFIX)
	cat $< | $(QF) $(QF_PARAMS) $*$(QHG_SUFFIX) > $@

endif



# Macro definition

GRAB_LANE_TILES=$(filter $(1)%, $(2))

#
# Generic rules to build files
#

# Make "first pass" alignments

# moved to GERALD.xml to define on per-lane basis, as make 3.78 won't override
# a global definition with a per-lane definition when needed
#%$(ALIGN_SUFFIX): $(EXPT_DIR)/%$(SEQ_FILE_SUFFIX) $(PA)
#	$(PA) $(PA_PARAMS) $<\
#	> $@

%$(QVAL_SUFFIX): %$(ALIGN_SUFFIX) $(EQP) \
$(EXPT_DIR)/%$(SIG_FILE_SUFFIX) $(EXPT_DIR)/%$(PRB_FILE_SUFFIX)
	$(EQP) $(EQP_PARAMS) $<\
	> $@
 
%$(QTABLE_SUFFIX): %$(QVAL_SUFFIX) $(QLC)
	$(QLC) $< > $@

%$(QCAL_SUFFIX): %$(QVAL_SUFFIX) %$(QTABLE_SUFFIX) $(QLC)
	$(QLA) $(QLA_PARAMS) $*$(QTABLE_SUFFIX) $< | \
	$(FQV) $(FQV_PARAMS) > $@
 
%$(QRAW_SUFFIX): $(EXPT_DIR)/%$(PRB_FILE_SUFFIX) $(CQ)
	$(CQ) $(CQ_PARAMS) $< > $@




# Make scored alignments from quality value files

%$(QALIGN_SUFFIX): $(EXPT_DIR)/%$(PRB_FILE_SUFFIX) $(PA)
	$(PA) $(PA_PARAMS) $<\
	> $@

# Make QC parameter files
%$(QHG_SUFFIX): $(EXPT_DIR)/%$(SIG_FILE_SUFFIX) $(QH)
	$(QH) $(QH_PARAMS) $<\
	> $@

# Default behaviour to make score files

ifdef CONTAM_FILE
%$(SCORE_SUFFIX): %$(ALIGN_SUFFIX) %$(CDIFF_SUFFIX) $(SC)
	cat $< | $(QF) '($$F[0]>0)' $*$(CDIFF_SUFFIX) | $(SC) $(SC_PARAMS) >$@ 
else
%$(SCORE_SUFFIX): %$(ALIGN_SUFFIX) $(SC)
	cat $< | $(SC) $(SC_PARAMS)  > $@ 
endif

# Realignment on per tile basis

# moved to GERALD.xml to define on per-lane basis, as make 3.78 won't override
# a global definition with a per-lane definition when needed
#%$(PREALIGN_SUFFIX): $(EXPT_DIR)/%$(SEQ_FILE_SUFFIX) $(PA)\
#%$(SCORE_SUFFIX)
#	$(PA) $(PA_PARAMS) -scoreFile $*$(SCORE_SUFFIX) $< > $@

%$(REALIGN_SUFFIX): %$(PREALIGN_SUFFIX) %$(QHG_SUFFIX)
	cat $< | $(QF) $(QF_PARAMS) $*$(QHG_SUFFIX) > $@

ifdef CONTAM_FILE
%$(RESCORE_SUFFIX): %$(REALIGN_SUFFIX) %$(CREDIFF_SUFFIX) $(SC)
	cat $< | $(QF) '($$F[0]>0)' $*$(CREDIFF_SUFFIX)|$(SC) $(SC_PARAMS) >$@ 
else
%$(RESCORE_SUFFIX): %$(REALIGN_SUFFIX)
	cat $< | $(SC) $(GENOME) > $@ 
endif

# Make pngs from rescore files
%$(RESCORE_PNG_SUFFIX): %$(RESCORE_SUFFIX)
	$(PE) $<

# Make pngs from align, realign and prb files
%$(PSH_PNG_SUFFIX): %$(RESCORE_SUFFIX)
	$(PSH) $@ $*$(ALIGN_SUFFIX) $*$(SCORE_SUFFIX) $*$(REALIGN_SUFFIX) $*$(RESCORE_SUFFIX) $(EXPT_DIR)/$*$(PRB_FILE_SUFFIX) $(USE_BASES_CRITERION)

# Make png of 0,1,2,3,4 errors from realign file
%$(PEC_PNG_SUFFIX): %$(REALIGN_SUFFIX)
	$(PEC) $< $@ 

# Make pngs of information content from align+realign+prb
%$(PIN_PNG_SUFFIX): %$(RESCORE_SUFFIX)
	$(PIN) $@ $*$(ALIGN_SUFFIX) $*$(REALIGN_SUFFIX) \
	$(EXPT_DIR)/$*$(PRB_FILE_SUFFIX) $(USE_BASES_CRITERION)



# Build lane coverage after second alignment
%_cov.txt: %_rescore
	cat $(call GRAB_LANE_TILES, $*, $(GOOD_REALIGN_FILES))\
	| $(BC) $(BC_PARAMS) > $@

all_cov.txt: $(LANES_BEST_ALIGN) $(LANES_COV)
	cat $(LANES_BEST_ALIGN) | $(BC) $(BC_PARAMS) > $@

%$(SMT_SUFFIX): $(EXPT_DIR)/%$(SIG_FILE_SUFFIX) %$(QHG_SUFFIX)
	$(SMT) $(SMT_PARAMS) $^ > $@

%$(SMT_PNG_SUFFIX): %$(SMT_SUFFIX)
	$(PIT) $^ $@


# Make error plots of all rescore files
$(ERROR_THUMB):  $(addsuffix $(RESCORE_PNG_SUFFIX), $(THUMBNAIL_TILES))
	$(CE) $(CE_PARAMS) > $@

# Prerequisites for SIGNAL_MEANS
$(SIGNAL_MEANS): $(SM_PREREQS)
	cat $^ > $@

# Run plotIntensity_for_IVC.pl
$(PLOT_INTENSITY): $(SIGNAL_MEANS) 
	$(PI) $(SIGNAL_MEANS) $(CURDIR)
	echo dummy > $@

# Run create_IVC_thumbnail.pl
$(IVC_THUMB): $(PLOT_INTENSITY)
	$(CI) $(CURDIR) > $@


# Build thumbnail of Signal_Means_Tile.pl output
$(SMT_THUMB) : $(addsuffix $(SMT_PNG_SUFFIX), $(THUMBNAIL_TILES))
	$(CE) $(CE_PARAMS_SMT) > $@

# Build thumbnail of sequence quality histograms
$(PSH_THUMB) : $(addsuffix $(PSH_PNG_SUFFIX), $(THUMBNAIL_TILES))
	$(CE) $(CE_PARAMS_PSH) > $@

# Build thumbnail of sequence quality histograms
$(PEC_THUMB) : $(addsuffix $(PEC_PNG_SUFFIX), $(THUMBNAIL_TILES))
	$(CE) $(CE_PARAMS_PEC) > $@

# Build thumbnail of information content histograms
$(PIN_THUMB) : $(addsuffix $(PIN_PNG_SUFFIX), $(THUMBNAIL_TILES))
	$(CE) $(CE_PARAMS_PIN) > $@



s_1: $(s_1_TARGET_LIST)
s_2: $(s_2_TARGET_LIST)
s_3: $(s_3_TARGET_LIST)
s_4: $(s_4_TARGET_LIST)
s_5: $(s_5_TARGET_LIST)
s_6: $(s_6_TARGET_LIST)
s_7: $(s_7_TARGET_LIST)
s_8: $(s_8_TARGET_LIST)


# Build by_tile thumbnail view of whatever is there
JER_PREREQS+= $(IVC_THUMB) $(SMT_THUMB) $(LANE_TARGETS)
$(JER_THUMB): $(JER_PREREQS)
	$(JER) $(CURDIR) > $@

$(BTT_THUMB) : $(ERROR_THUMB) $(IVC_THUMB) $(SMT_THUMB) $(PSH_THUMB) $(PEC_THUMB) $(PIN_THUMB) $(JER_THUMB)
	$(BTT) $(CURDIR) > $@

$(RUN_REPORT): $(BTT_THUMB)
	$(RR) $(RR_PARAMS)
	@echo dummy > $@



# GERALD will run make self_test on the created make file
# and parse the output to check for problems
s_%_check_use_bases: 
	@echo $(USE_BASES_CRITERION) | perl -lane \
	'{ die "\nERROR: Invalid USE_BASES string: $$_\n\n" unless (/^(odd|all|[NnYn]+)$$/);}'
	@echo $(USE_BASES_CRITERION) $(READ_LENGTH) | \
	perl -lane '{ if ($$F[0]=~/^[NnYn]+/) { ($$b=$$F[0])=~s/[Nn]//g; $$a=length($$b); die "\nERROR: $$a Ys in USE_BASES string $$F[0], but need $$F[1] to match READ_LENGTH\n\n" unless ($$a==$$F[1])}}'


# target for debugging
s_%_self_test: s_%_check_use_bases
	@echo $(DIRS_TO_CHECK) | perl -lane \
	'{for (@F) {die "\nERROR: did not find dir $$_\n\n" unless (-d $$_)}}'
	@echo $(FILES_TO_CHECK) | perl -lane \
	'{for (@F) {die "\nERROR: did not find file $$_\n\n" unless (-e $$_)}}'
	@echo $(EXECS_TO_CHECK) | perl -lane \
	'{for (@F) {die "\nERROR: file $$_ not executable\n\n" unless(-x $$_)}}'
self_test: $(patsubst %,%_self_test,$(LANES))



qhg: $(ALL_QHG_FILES)


qalign: $(LANES:%=%_qalign)

rescore: $(LANES:%=%_rescore)

lra: $(ALL_LANES_RA) summary_lra.txt plot_calls 

tidy:
	find . -empty -exec rm {} \;

clean_qcal:
	-rm -f *_qraw.txt *_qtable.txt *_qcal.txt *qreport.txt *qcalreport.txt 

clean3:
	-rm -f $(addprefix *, $(wordlist 17,50,$(OUTPUT_FILE_TYPES)))
clean2:
	-rm -f $(addprefix *, $(wordlist 9,16,$(OUTPUT_FILE_TYPES)))
clean1:
	-rm -f $(addprefix *, $(wordlist 1,8,$(OUTPUT_FILE_TYPES)))
clean0:
	-rm -f core core.* *.png *_coverage *_sequence.txt

clean: clean_qcal clean0 clean1 clean2 clean3
	@echo Finished cleaning.

clean_intermediate:
	@echo Nothing to be cleaned.

compress:
	gzip *.txt

uncompress:
	gunzip *.txt.gz

# End of generated Makefile
